# Generate the output file path dynamically for each country
output_file <- paste0('figures/', country, '_adf_test_results.txt')
# Call the perform_adf_test function for the country's data
perform_adf_test(country_data, output_file = output_file)
}
# Loop over each country
for (country in unique(df$country)) {
# Subset the data for the current country
country_data <- df[df$country == country, ]
# Generate the output file path dynamically for each country
output_file <- paste0('figures/adf_test_results_', country, '.txt')
# Call the perform_adf_test function for the country's data
perform_adf_test(country_data, output_file = output_file)
}
# Generate the correlation plot
corrplot(cor_matrix, method = "circle", type = "upper",
tl.col = "black", tl.srt = 90, diag = FALSE)
#
df
to_drop <- c('evstock', 'evchargpoint', 'industprod', 'totreserves', 'milleagekm')
df <- df %>% select(-to_drop)
to_drop <- c('evstock', 'evchargpnt', 'industprod', 'totreserves', 'milleagekm')
df <- df %>% select(-to_drop)
df
# ADF
# Perform ADF test and save results to a text file
perform_adf_test <- function(data_frame, output_file = "adf_test_results.txt") {
# Open a connection to the file
file_conn <- file(output_file, open = "wt")
# Write results to the file
for (col in names(data_frame)) {
# Check if the column is numeric (time series data is usually numeric)
if (is.numeric(data_frame[[col]])) {
# Perform the Augmented Dickey-Fuller test
adf_test <- ur.df(data_frame[[col]], type = "trend", selectlags = "AIC")
# Write column name
cat("\nADF Test for", col, ":\n", file = file_conn)
# Write test summary to file
cat(capture.output(summary(adf_test)), file = file_conn, sep = "\n")
}
}
# Close the file connection
close(file_conn)
cat("ADF test results saved to", output_file, "\n")
}
# Loop over each country
for (country in unique(df$country)) {
# Subset the data for the current country
country_data <- df[df$country == country, ]
# Generate the output file path dynamically for each country
output_file <- paste0('figures/adf_test_results_', country, '.txt')
# Call the perform_adf_test function for the country's data
perform_adf_test(country_data, output_file = output_file)
}
View(df)
# Perform ADF test and save results to a text file
perform_adf_test <- function(data_frame, output_file = "adf_test_results.txt") {
# Open a connection to the file
file_conn <- file(output_file, open = "wt")
# Write results to the file
for (col in names(data_frame)) {
# Check if the column is numeric (time series data is usually numeric)
if (is.numeric(data_frame[[col]])) {
# Perform the Augmented Dickey-Fuller test
adf_test <- ur.df(data_frame[[col]], type = "drift", selectlags = "AIC")
# Write column name
cat("\nADF Test for", col, ":\n", file = file_conn)
# Write test summary to file
cat(capture.output(summary(adf_test)), file = file_conn, sep = "\n")
}
}
# Close the file connection
close(file_conn)
cat("ADF test results saved to", output_file, "\n")
}
# Loop over each country
for (country in unique(df$country)) {
# Subset the data for the current country
country_data <- df[df$country == country, ]
# Generate the output file path dynamically for each country
output_file <- paste0('figures/adf_test_results_', country, '.txt')
# Call the perform_adf_test function for the country's data
perform_adf_test(country_data, output_file = output_file)
}
# ADF
# Perform ADF test and save results to a text file
perform_adf_test <- function(data_frame, output_file = "adf_test_results.txt") {
# Open a connection to the file
file_conn <- file(output_file, open = "wt")
# Write results to the file
for (col in names(data_frame)) {
# Check if the column is numeric (time series data is usually numeric)
if (is.numeric(data_frame[[col]])) {
# Perform the Augmented Dickey-Fuller test
adf_test <- ur.df(data_frame[[col]], type = "trend", selectlags = "AIC")
# Write column name
cat("\nADF Test for", col, ":\n", file = file_conn)
# Write test summary to file
cat(capture.output(summary(adf_test)), file = file_conn, sep = "\n")
}
}
# Close the file connection
close(file_conn)
cat("ADF test results saved to", output_file, "\n")
}
# Loop over each country
for (country in unique(df$country)) {
# Subset the data for the current country
country_data <- df[df$country == country, ]
# Generate the output file path dynamically for each country
output_file <- paste0('figures/adf_test_results_', country, '.txt')
# Call the perform_adf_test function for the country's data
perform_adf_test(country_data, output_file = output_file)
}
# Results of the analysis
# ADF
# Perform ADF test and save results to a text file
perform_adf_test <- function(data_frame, output_file = "adf_test_results.txt") {
# Open a connection to the file
file_conn <- file(output_file, open = "wt")
# Write results to the file
for (col in names(data_frame)) {
# Check if the column is numeric (time series data is usually numeric)
if (is.numeric(data_frame[[col]])) {
# Perform the Augmented Dickey-Fuller test
adf_test <- ur.df(data_frame[[col]], type = "drift", selectlags = "AIC")
# Write column name
cat("\nADF Test for", col, ":\n", file = file_conn)
# Write test summary to file
cat(capture.output(summary(adf_test)), file = file_conn, sep = "\n")
}
}
# Close the file connection
close(file_conn)
cat("ADF test results saved to", output_file, "\n")
}
# Loop over each country
for (country in unique(df$country)) {
# Subset the data for the current country
country_data <- df[df$country == country, ]
# Generate the output file path dynamically for each country
output_file <- paste0('figures/adf_test_results_', country, '.txt')
# Call the perform_adf_test function for the country's data
perform_adf_test(country_data, output_file = output_file)
}
# Perform ADF test and save results to a text file
perform_adf_test <- function(data_frame, output_file = "adf_test_results.txt") {
# Open a connection to the file
file_conn <- file(output_file, open = "wt")
# Write results to the file
for (col in names(data_frame)) {
# Check if the column is numeric (time series data is usually numeric)
if (is.numeric(data_frame[[col]])) {
# Perform the Augmented Dickey-Fuller test
adf_test <- ur.df(data_frame[[col]], type = "trend", selectlags = "BIC")
# Write column name
cat("\nADF Test for", col, ":\n", file = file_conn)
# Write test summary to file
cat(capture.output(summary(adf_test)), file = file_conn, sep = "\n")
}
}
# Close the file connection
close(file_conn)
cat("ADF test results saved to", output_file, "\n")
}
# Loop over each country
for (country in unique(df$country)) {
# Subset the data for the current country
country_data <- df[df$country == country, ]
# Generate the output file path dynamically for each country
output_file <- paste0('figures/adf_test_results_', country, '.txt')
# Call the perform_adf_test function for the country's data
perform_adf_test(country_data, output_file = output_file)
}
# Perform ADF test and save results to a text file
perform_adf_test <- function(data_frame, output_file = "adf_test_results.txt") {
# Open a connection to the file
file_conn <- file(output_file, open = "wt")
# Write results to the file
for (col in names(data_frame)) {
# Check if the column is numeric (time series data is usually numeric)
if (is.numeric(data_frame[[col]])) {
# Perform the Augmented Dickey-Fuller test
adf_test <- ur.df(data_frame[[col]], type = "trend", selectlags = "AIC")
# Write column name
cat("\nADF Test for", col, ":\n", file = file_conn)
# Write test summary to file
cat(capture.output(summary(adf_test)), file = file_conn, sep = "\n")
}
}
# Close the file connection
close(file_conn)
cat("ADF test results saved to", output_file, "\n")
}
# Loop over each country
for (country in unique(df$country)) {
# Subset the data for the current country
country_data <- df[df$country == country, ]
# Generate the output file path dynamically for each country
output_file <- paste0('figures/adf_test_results_', country, '.txt')
# Call the perform_adf_test function for the country's data
perform_adf_test(country_data, output_file = output_file)
}
# Results of the analysis
install.packages('lmtest')
install.packages("sandwich")
# AUTOPLOTS
for (col in names(df)[-1]) {
print(autoplot(df, !!sym(col)) + ggtitle(paste("Autoplot of", col)))
}
View(df)
###################### DATASETS
# Separate into two sets, where canonical uses the variables with academic support
df_canonical <- df %>% select(c('cpi','gdp', 'co2emit', 'lifexpect', 'renergycon','pm25exp'))
df_novelty <- df
###################### BASELINES
# Pooled OLS
pooled_df <- df_canonical %>% select(-c('year','country'))
# Separate into two sets, where canonical uses the variables with academic support
df_canonical <- df %>% select(c('year','country', 'cpi','gdp', 'co2emit', 'lifexpect', 'renergycon','pm25exp'))
df_novelty <- df
###################### BASELINES
# Pooled OLS
pooled_df <- df_canonical %>% select(-c('year','country'))
model <- lm(target ~ ., data = pooled_df)
# Pooled OLS
pooled_df <- df_canonical %>% select(-c('year','country'))
model <- lm(evsales ~ ., data = pooled_df)
pooled_df <- df_canonical %>% select(-c('year','country'))
model <- pooled_df %>% lm(evsales ~ .)
pooled_df <- df_canonical %>% select(-c('year','country'))
model <- pooled_df %>% lm(evsales ~ ., data = pooled_df)
pooled_df <- df_canonical %>% select(-c('year','country'))
# Separate into two sets, where canonical uses the variables with academic support
df_canonical <- df %>% select(c('evsales', 'year','country', 'cpi','gdp', 'co2emit', 'lifexpect', 'renergycon','pm25exp'))
df_novelty <- df
pooled_df <- df_canonical %>% select(-c('year','country'))
model <- pooled_df %>% lm(pooled_df$evsales ~ ., data = pooled_df)
pooled_df
model <- lm(pooled_df$evsales ~ ., data = pooled_df)
# Perform the White test
bptest(model, ~ fitted(model) + I(fitted(model)^2), data = your_data)
library(openxlsx)
library(tidyverse)
library(corrplot)
library(zoo)
library(urca)
library(sandwich)
library(lmtest)
library(plm)
install.packages('plm')
# Perform the White test
bptest(model, ~ fitted(model) + I(fitted(model)^2), data = your_data)
bptest(model, ~ fitted(model) + I(fitted(model)^2), data = pooled_df)
bptest(model)
bptest(model)
# Fit a fixed effects model (including country and year fixed effects)
model <- lm(target ~ . + factor(df_canonical$country) + factor(df_canonical$year), data = df_canonical)
# Fit a fixed effects model (including country and year fixed effects)
model <- lm(df_canonical$evsales ~ . + factor(df_canonical$country) + factor(df_canonical$year), data = df_canonical)
# Perform the Breusch-Pagan test
bptest(model)
# Convert the data to a panel data frame
panel_data <- pdata.frame(df_canonical, index = c("country", "year"))
library(openxlsx)
library(tidyverse)
library(corrplot)
library(zoo)
library(urca)
library(sandwich)
library(lmtest)
library(plm)
library(fpp3)
# Convert the data to a panel data frame
panel_data <- pdata.frame(df_canonical, index = c("country", "year"))
# Fit a random effects model
model <- plm(target ~ ., data = panel_data, model = "random")
# Convert the data to a panel data frame
panel_data <- pdata.frame(df_canonical, index = c("country", "year"))
# Fit a random effects model
model <- plm(panel_data$evsales ~ ., data = panel_data, model = "random")
############################### LIBRARIES ######################################
library(openxlsx)
library(tidyverse)
library(corrplot)
library(zoo)
library(urca)
library(sandwich)
library(lmtest)
library(plm)
library(fpp3)
############################### INGESTION ######################################
# Import the data
df <- read.csv("data/dataset.csv")
# View(df)
# Convert to tsibble
ts <- as_tsibble(df, key=country, index=year)
#View(ts)
########################### DATA TREATMENT #####################################
# Check NAs
# Checking the number of missing values in each column
data.frame(colSums(is.na(df)))
# colSums.is.na.df..
# country                          0
# year                             0
# evsales                          0
# evstock                          0
# evchargpnt                       0
# cpiyoy                           0
# industprod                       0
# totreserves                      0
# forexrate                        0
# cpi                              0
# gdp                              0
# unemprate                        0
# oilprice                         0
# evavgprice                       0
# milleagekm                       0
# lithbatpriceusd                  0
# newcaravgprice                   0
# pm25exp                         16
# co2emit                          0
# renergycon                       8
# lifexpect                        0
# Filling missing values using spline interpolation
df_filled <- df  # Make a copy of the original data frame
# Apply linear interpolation to each numeric column
for (col in names(df_filled)) {
if (is.numeric(df_filled[[col]])) {
df_filled[[col]] <- na.spline(df_filled[[col]])
}
}
df <- df_filled
########################### INITIAL VISUALIZATION ##############################
# AUTOPLOTS
for (col in names(ts)[-1]) {
print(autoplot(ts, !!sym(col)) + ggtitle(paste("Autoplot of", col)))
}
# PEARSON CORRELATION
# Select numeric (excludes)
numeric_df <- df[, sapply(df, is.numeric)]
# Extract column names from the dataframe
vars <- colnames(numeric_df)
# Calculate the correlation matrix
corr_matrix <- cor(df[, vars], use = "pairwise.complete.obs")
# Generate the correlation plot
corrplot(cor_matrix, method = "circle", type = "upper",
tl.col = "black", tl.srt = 90, diag = FALSE)
# The variables evstock, evchargpoint, industprod, totreserves, millieagekm were
# dropped at this stage as they exhibit exceedingly large linear correlation
# (abs(value) < .8) with other variables.
to_drop <- c('evstock', 'evchargpnt', 'industprod', 'totreserves', 'milleagekm')
df <- df %>% select(-to_drop)
############################ STATISTICAL TESTS ################################
# ADF
# Perform ADF test and save results to a text file
perform_adf_test <- function(data_frame, output_file = "adf_test_results.txt") {
# Open a connection to the file
file_conn <- file(output_file, open = "wt")
# Write results to the file
for (col in names(data_frame)) {
# Check if the column is numeric (time series data is usually numeric)
if (is.numeric(data_frame[[col]])) {
# Perform the Augmented Dickey-Fuller test
adf_test <- ur.df(data_frame[[col]], type = "trend", selectlags = "AIC")
# Write column name
cat("\nADF Test for", col, ":\n", file = file_conn)
# Write test summary to file
cat(capture.output(summary(adf_test)), file = file_conn, sep = "\n")
}
}
# Close the file connection
close(file_conn)
cat("ADF test results saved to", output_file, "\n")
}
# Loop over each country
for (country in unique(df$country)) {
# Subset the data for the current country
country_data <- df[df$country == country, ]
# Generate the output file path dynamically for each country
output_file <- paste0('figures/adf_test_results_', country, '.txt')
# Call the perform_adf_test function for the country's data
perform_adf_test(country_data, output_file = output_file)
}
# Results of the analysis support the idea that all variables selected exhibit
# non-stationary behavior for most countries - notable exceptions are:
# CHN, pm25
# FRA, unemp (10%)
# JPN, evsales(5%), co2emit(5%)
# USA, co2emit(5%)
# All of which show deterministic and stationary trends.
###################### DATASETS
# Separate into two sets, where canonical uses the variables with academic support
df_canonical <- df %>% select(c('evsales', 'year','country', 'cpi', 'newcaravgprice','gdp', 'co2emit', 'lifexpect', 'renergycon','pm25exp'))
df_novelty <- df
###################### BASELINE
# Pooled OLS
pooled_df <- df_canonical %>% select(-c('year','country'))
model <- lm(pooled_df$evsales ~ ., data = pooled_df)
# Perform the Breusch-Pagan test
bptest(model)
# studentized Breusch-Pagan test
# data:  model
# BP = 38.678, df = 6, p-value = 8.275e-07
# Concluding that to model the data using Pooled OLS, heteroscedasticity must be
# corrected.
# Fixed effects model
# Fit a fixed effects model (including country and year fixed effects)
model <- lm(df_canonical$evsales ~ . + factor(df_canonical$country) + factor(df_canonical$year), data = df_canonical)
# Perform the Breusch-Pagan test
bptest(model)
# studentized Breusch-Pagan test
#
# data:  model
# BP = 65.578, df = 24, p-value = 1.001e-05
# Random effects model
# Convert the data to a panel data frame
panel_data <- pdata.frame(df_canonical, index = c("country", "year"))
# Fit a random effects model
model <- plm(panel_data$evsales ~ ., data = panel_data, model = "random")
# Separate into two sets, where canonical uses the variables with academic support
df_canonical <- df %>% select(c('evsales', 'year','country', 'cpi', 'co2emit', 'lifexpect', 'renergycon','pm25exp'))
df_novelty <- df
###################### BASELINE
# Pooled OLS
pooled_df <- df_canonical %>% select(-c('year','country'))
model <- lm(pooled_df$evsales ~ ., data = pooled_df)
# Perform the Breusch-Pagan test
bptest(model)
# studentized Breusch-Pagan test
# data:  model
# BP = 38.678, df = 6, p-value = 8.275e-07
# Concluding that to model the data using Pooled OLS, heteroscedasticity must be
# corrected.
# Fixed effects model
# Fit a fixed effects model (including country and year fixed effects)
model <- lm(df_canonical$evsales ~ . + factor(df_canonical$country) + factor(df_canonical$year), data = df_canonical)
# Perform the Breusch-Pagan test
bptest(model)
# studentized Breusch-Pagan test
#
# data:  model
# BP = 65.578, df = 24, p-value = 1.001e-05
# Random effects model
# Convert the data to a panel data frame
panel_data <- pdata.frame(df_canonical, index = c("country", "year"))
# Fit a random effects model
model <- plm(panel_data$evsales ~ ., data = panel_data, model = "random")
# Separate into two sets, where canonical uses the variables with academic support
df_canonical <- df %>% select(c('evsales', 'year','country', 'cpi', 'co2emit', 'lifexpect', 'renergycon','pm25exp'))
df_novelty <- df
# Convert the data to a panel data frame
panel_data <- pdata.frame(df_canonical, index = c("country", "year"))
panel_data
# Fit a random effects model
model <- plm(panel_data$evsales ~ ., data = panel_data, model = "random")
# Separate into two sets, where canonical uses the variables with academic support
df_canonical <- df %>% select(c('evsales', 'year','country', 'cpi', 'newcaravgprice','gdp', 'co2emit', 'lifexpect', 'renergycon','pm25exp'))
df_novelty <- df
# Convert the data to a panel data frame
panel_data <- pdata.frame(df_canonical, index = c("country", "year"))
# Fit a random effects model
model <- plm(panel_data$evsales ~ ., data = panel_data, model = "random")
# Fit a random effects model
model <- plm(panel_data$evsales ~ ., data = panel_data, model = "between")
# Perform the White test
bptest(model)
# Convert the data to a panel data frame
panel_data <- pdata.frame(df_canonical, index = c("country", "year"))
# Fit a random effects model
model <- plm(panel_data$evsales ~ ., data = panel_data, model = "between")
# Perform the White test
bptest(model)
# Fit a random effects model
model <- plm(panel_data$evsales ~ ., data = panel_data, model = "between")
bptest(model)
model
model
panel_data <- pdata.frame(df_canonical, index = c("country", "year"))
panel_data <- pdata.frame(df_canonical, index = c("country", "year"))
model <- plm(panel_data$evsales ~ ., data = panel_data, model = "between")
# Perform the White t
# Perform the White test
bptest(model)
model
features <- panel_data %>% select(-'evsales')
features
panel_data <- panel_data %>% select(-'evsales')
# Fit a random effects model
model <- plm(panel_data$evsales ~ , data = panel_data, model = "between")
model <- plm(panel_data$evsales ~ ., data = panel_data, model = "between")
# Convert the data to a panel data frame
panel_data <- pdata.frame(df_canonical, index = c("country", "year"))
target <- panel_data$evsales
panel_data <- panel_data %>% select(-'evsales')
# Fit a random effects model
model <- plm(panel_data$evsales ~ ., data = panel_data, model = "between")
panel_data <- pdata.frame(df_canonical, index = c("country", "year"))
panel_data <- panel_data %>% select(-'evsales')
# Fit a random effects model
model <- plm(df_canonical$evsales ~ ., data = panel_data, model = "between")
model
model
# Perform the White test
bptest(model)
# Fit a fixed effects model (including country and year fixed effects)
model <- lm(df_canonical$evsales ~ . + factor(df_canonical$country) + factor(df_canonical$year), data = df_canonical)
model
model <- plm(df_canonical$evsales ~ ., data = panel_data, model = "between")
# Perform the White test
bptest(model)
model
